<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: ThinkingSphinx::SearchMethods::ClassMethods</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">ThinkingSphinx::SearchMethods::ClassMethods</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../../files/lib/thinking_sphinx/search_methods_rb.html">
                lib/thinking_sphinx/search_methods.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">



   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000057">count</a>&nbsp;&nbsp;
      <a href="#M000059">facets</a>&nbsp;&nbsp;
      <a href="#M000054">search</a>&nbsp;&nbsp;
      <a href="#M000053">search_context</a>&nbsp;&nbsp;
      <a href="#M000058">search_count</a>&nbsp;&nbsp;
      <a href="#M000056">search_for_id</a>&nbsp;&nbsp;
      <a href="#M000055">search_for_ids</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000057" class="method-detail">
        <a name="M000057"></a>

        <div class="method-heading">
          <a href="ClassMethods.src/M000057.html" target="Code" class="method-signature"
            onclick="popupCode('ClassMethods.src/M000057.html');return false;">
          <span class="method-name">count</span><span class="method-args">(*args)</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000059" class="method-detail">
        <a name="M000059"></a>

        <div class="method-heading">
          <a href="ClassMethods.src/M000059.html" target="Code" class="method-signature"
            onclick="popupCode('ClassMethods.src/M000059.html');return false;">
          <span class="method-name">facets</span><span class="method-args">(*args)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Model.facets *args ThinkingSphinx.facets *args ThinkingSphinx.facets *args,
:all_facets =&gt; true ThinkingSphinx.facets *args, :class_facet =&gt;
false
</p>
        </div>
      </div>

      <div id="method-M000054" class="method-detail">
        <a name="M000054"></a>

        <div class="method-heading">
          <a href="ClassMethods.src/M000054.html" target="Code" class="method-signature"
            onclick="popupCode('ClassMethods.src/M000054.html');return false;">
          <span class="method-name">search</span><span class="method-args">(*args)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Searches through the Sphinx indexes for relevant matches. There&#8216;s
various ways to <a href="ClassMethods.html#M000054">search</a>, sort, group
and filter - which are covered below.
</p>
<p>
Also, if you have WillPaginate installed, the <a
href="ClassMethods.html#M000054">search</a> method can be used just like
paginate. The same parameters - :page and :per_page - work as expected, and
the returned result set can be used by the will_paginate helper.
</p>
<h2>Basic Searching</h2>
<p>
The simplest way of searching is straight text.
</p>
<pre>
  ThinkingSphinx.search &quot;pat&quot;
  ThinkingSphinx.search &quot;google&quot;
  User.search &quot;pat&quot;, :page =&gt; (params[:page] || 1)
  Article.search &quot;relevant news issue of the day&quot;
</pre>
<p>
If you specify :include, like in an find call, this will be respected when
loading the relevant models from the <a
href="ClassMethods.html#M000054">search</a> results.
</p>
<pre>
  User.search &quot;pat&quot;, :include =&gt; :posts
</pre>
<h2>Match Modes</h2>
<p>
Sphinx supports 5 different matching modes. By default Thinking Sphinx uses
:all, which unsurprisingly requires all the supplied <a
href="ClassMethods.html#M000054">search</a> terms to match a result.
</p>
<p>
Alternative modes include:
</p>
<pre>
  User.search &quot;pat allan&quot;, :match_mode =&gt; :any
  User.search &quot;pat allan&quot;, :match_mode =&gt; :phrase
  User.search &quot;pat | allan&quot;, :match_mode =&gt; :boolean
  User.search &quot;@name pat | @username pat&quot;, :match_mode =&gt; :extended
</pre>
<p>
Any will find results with any of the <a
href="ClassMethods.html#M000054">search</a> terms. Phrase treats the <a
href="ClassMethods.html#M000054">search</a> terms a single phrase instead
of individual words. Boolean and extended allow for more complex query
syntax, refer to the sphinx documentation for further details.
</p>
<h2>Weighting</h2>
<p>
Sphinx has support for weighting, where matches in one field can be
considered more important than in another. Weights are integers, with 1 as
the default. They can be set per-<a
href="ClassMethods.html#M000054">search</a> like this:
</p>
<pre>
  User.search &quot;pat allan&quot;, :field_weights =&gt; { :alias =&gt; 4, :aka =&gt; 2 }
</pre>
<p>
If you&#8216;re searching multiple models, you can set per-index weights:
</p>
<pre>
  ThinkingSphinx.search &quot;pat&quot;, :index_weights =&gt; { User =&gt; 10 }
</pre>
<p>
See <a
href="http://sphinxsearch.com/doc.html#weighting">sphinxsearch.com/doc.html#weighting</a>
for further details.
</p>
<h2>Searching by Fields</h2>
<p>
If you want to step it up a level, you can limit your <a
href="ClassMethods.html#M000054">search</a> terms to specific fields:
</p>
<pre>
  User.search :conditions =&gt; {:name =&gt; &quot;pat&quot;}
</pre>
<p>
This uses Sphinx&#8216;s extended match mode, unless you specify a
different match mode explicitly (but then this way of searching won&#8216;t
work). Also note that you don&#8216;t need to put in a <a
href="ClassMethods.html#M000054">search</a> string.
</p>
<h2>Searching by Attributes</h2>
<p>
Also known as filters, you can limit your searches to documents that have
specific values for their attributes. There are three ways to do this. The
first two techniques work in all scenarios - using the :with or :with_all
options.
</p>
<pre>
  ThinkingSphinx.search :with =&gt; {:tag_ids =&gt; 10}
  ThinkingSphinx.search :with =&gt; {:tag_ids =&gt; [10,12]}
  ThinkingSphinx.search :with_all =&gt; {:tag_ids =&gt; [10,12]}
</pre>
<p>
The first :with <a href="ClassMethods.html#M000054">search</a> will match
records with a tag_id attribute of 10. The second :with will match records
with a tag_id attribute of 10 OR 12. If you need to find records that are
tagged with ids 10 AND 12, you will need to use the :with_all <a
href="ClassMethods.html#M000054">search</a> parameter. This is particuarly
useful in conjunction with Multi Value Attributes (MVAs).
</p>
<p>
The third filtering technique is only viable if you&#8216;re searching with
a specific model (not multi-model searching). With a single model, Thinking
Sphinx can figure out what attributes and fields are available, so you can
put it all in the :conditions hash, and it will sort it out.
</p>
<pre>
  Node.search :conditions =&gt; {:parent_id =&gt; 10}
</pre>
<p>
Filters can be single values, arrays of values, or ranges.
</p>
<pre>
  Article.search &quot;East Timor&quot;, :conditions =&gt; {:rating =&gt; 3..5}
</pre>
<h2>Excluding by Attributes</h2>
<p>
Sphinx also supports negative filtering - where the filters are of
attribute values to exclude. This is done with the :without option:
</p>
<pre>
  User.search :without =&gt; {:role_id =&gt; 1}
</pre>
<h2>Excluding by Primary Key</h2>
<p>
There is a shortcut to exclude records by their <a
href="../ActiveRecord.html">ActiveRecord</a> primary key:
</p>
<pre>
  User.search :without_ids =&gt; 1
</pre>
<p>
Pass an array or a single value.
</p>
<p>
The primary key must be an integer as a negative filter is used. Note that
for multi-model <a href="ClassMethods.html#M000054">search</a>, an id may
occur in more than one model.
</p>
<h2>Infix (Star) Searching</h2>
<p>
Enable infix searching by something like this in config/sphinx.yml:
</p>
<pre>
  development:
    enable_star: 1
    min_infix_len: 2
</pre>
<p>
Note that this will make indexing take longer.
</p>
<p>
With those settings (and after reindexing), wildcard asterisks can be used
in queries:
</p>
<pre>
  Location.search &quot;*elbourn*&quot;
</pre>
<p>
To automatically add asterisks around every token (but not operators), pass
the :star option:
</p>
<pre>
  Location.search &quot;elbourn -ustrali&quot;, :star =&gt; true,
    :match_mode =&gt; :boolean
</pre>
<p>
This would become &quot;<b>elbourn</b> -<b>ustrali</b>&quot;. The :star
option only adds the asterisks. You need to make the config/sphinx.yml
changes yourself.
</p>
<p>
By default, the tokens are assumed to match the regular expression /\w+/u+.
If you&#8216;ve modified the charset_table, pass another regular
expression, e.g.
</p>
<pre>
  User.search(&quot;oo@bar.c&quot;, :star =&gt; /[\w@.]+/u)
</pre>
<p>
to <a href="ClassMethods.html#M000054">search</a> for
&quot;*oo@bar.c*&quot; and not &quot;<b>oo</b>@<b>bar</b>.<b>c</b>&quot;.
</p>
<h2>Sorting</h2>
<p>
Sphinx can only sort by attributes, so generally you will need to avoid
using field names in your :order option. However, if you&#8216;re searching
on a single model, and have specified some fields as sortable, you can use
those field names and Thinking Sphinx will interpret accordingly. Remember:
this will only happen for single-model searches, and only through the
:order option.
</p>
<pre>
  Location.search &quot;Melbourne&quot;, :order =&gt; :state
  User.search :conditions =&gt; {:role_id =&gt; 2}, :order =&gt; &quot;name ASC&quot;
</pre>
<p>
Keep in mind that if you use a string, you <b>must</b> specify the
direction (ASC or DESC) else Sphinx won&#8216;t return any results. If you
use a symbol then Thinking Sphinx assumes ASC, but if you wish to state
otherwise, use the :sort_mode option:
</p>
<pre>
  Location.search &quot;Melbourne&quot;, :order =&gt; :state, :sort_mode =&gt; :desc
</pre>
<p>
Of course, there are other sort modes - check out the Sphinx <a
href="http://sphinxsearch.com/doc.html">documentation</a> for that level of
detail though.
</p>
<p>
If desired, you can sort by a column in your model instead of a sphinx
field or attribute. This sort only applies to the current page, so is most
useful when performing a <a href="ClassMethods.html#M000054">search</a>
with a single page of results.
</p>
<pre>
  User.search(&quot;pat&quot;, :sql_order =&gt; &quot;name&quot;)
</pre>
<h2>Grouping</h2>
<p>
For this you can use the group_by, group_clause and group_function options
- which are all directly linked to Sphinx&#8216;s expectations. No magic
from Thinking Sphinx. It can get a little tricky, so make sure you read all
the relevant <a
href="http://sphinxsearch.com/doc.html#clustering">documentation</a> first.
</p>
<p>
Grouping is done via three parameters within the options hash
</p>
<ul>
<li><tt>:group_function</tt> determines the way grouping is done

</li>
<li><tt>:group_by</tt> determines the field which is used for grouping

</li>
<li><tt>:group_clause</tt> determines the sorting order

</li>
</ul>
<p>
As a convenience, you can also use
</p>
<ul>
<li><tt>:group</tt>

</li>
</ul>
<p>
which sets :group_by and defaults to :group_function of :attr
</p>
<h3>group_function</h3>
<p>
Valid values for :group_function are
</p>
<ul>
<li><tt>:day</tt>, <tt>:week</tt>, <tt>:month</tt>, <tt>:year</tt> - Grouping
is done by the respective timeframes.

</li>
<li><tt>:attr</tt>, <tt>:attrpair</tt> - Grouping is done by the specified
attributes(s)

</li>
</ul>
<h3>group_by</h3>
<p>
This parameter denotes the field by which grouping is done. Note that the
specified field must be a sphinx attribute or index.
</p>
<h3>group_clause</h3>
<p>
This determines the sorting order of the groups. In a grouping <a
href="ClassMethods.html#M000054">search</a>, the matches within a group
will sorted by the <tt>:sort_mode</tt> and <tt>:order</tt> parameters. The
group matches themselves however, will be sorted by <tt>:group_clause</tt>.
</p>
<p>
The syntax for this is the same as an order parameter in extended sort
mode. Namely, you can specify an SQL-like sort expression with up to 5
attributes (including internal attributes), eg: &quot;@relevance DESC,
price ASC, @id DESC&quot;
</p>
<h3>Grouping by timestamp</h3>
<p>
Timestamp grouping groups off items by the day, week, month or year of the
attribute given. In order to do this you need to define a timestamp
attribute, which pretty much looks like the standard defintion for any
attribute.
</p>
<pre>
  define_index do
    #
    # All your other stuff
    #
    has :created_at
  end
</pre>
<p>
When you need to fire off your <a
href="ClassMethods.html#M000054">search</a>, it&#8216;ll go something to
the tune of
</p>
<pre>
  Fruit.search &quot;apricot&quot;, :group_function =&gt; :day,
    :group_by =&gt; 'created_at'
</pre>
<p>
The <tt>@groupby</tt> special attribute will contain the date for that
group. Depending on the <tt>:group_function</tt> parameter, the date format
will be:
</p>
<ul>
<li><tt>:day</tt> - YYYYMMDD

</li>
<li><tt>:week</tt> - YYYYNNN (NNN is the first day of the week in question,
counting from the start of the year )

</li>
<li><tt>:month</tt> - YYYYMM

</li>
<li><tt>:year</tt> - YYYY

</li>
</ul>
<h3>Grouping by attribute</h3>
<p>
The syntax is the same as grouping by timestamp, except for the fact that
the <tt>:group_function</tt> parameter is changed.
</p>
<pre>
  Fruit.search &quot;apricot&quot;, :group_function =&gt; :attr, :group_by =&gt; 'size'
</pre>
<h2>Geo/Location Searching</h2>
<p>
Sphinx - and therefore Thinking Sphinx - has the facility to <a
href="ClassMethods.html#M000054">search</a> around a geographical point,
using a given latitude and longitude. To take advantage of this, you will
need to have both of those values in attributes. To <a
href="ClassMethods.html#M000054">search</a> with that point, you can then
use one of the following syntax examples:
</p>
<pre>
  Address.search &quot;Melbourne&quot;, :geo =&gt; [1.4, -2.217],
    :order =&gt; &quot;@geodist asc&quot;
  Address.search &quot;Australia&quot;, :geo =&gt; [-0.55, 3.108],
    :order =&gt; &quot;@geodist asc&quot; :latitude_attr =&gt; &quot;latit&quot;,
    :longitude_attr =&gt; &quot;longit&quot;
</pre>
<p>
The first example applies when your latitude and longitude attributes are
named any of lat, latitude, lon, long or longitude. If that&#8216;s not the
case, you will need to explicitly state them in your <a
href="ClassMethods.html#M000054">search</a>, <em>or</em> you can do so in
your model:
</p>
<pre>
  define_index do
    has :latit  # Float column, stored in radians
    has :longit # Float column, stored in radians

    set_property :latitude_attr   =&gt; &quot;latit&quot;
    set_property :longitude_attr  =&gt; &quot;longit&quot;
  end
</pre>
<p>
Now, geo-location searching really only has an affect if you have a filter,
sort or grouping clause related to it - otherwise it&#8216;s just a normal
<a href="ClassMethods.html#M000054">search</a>, and _will not_ return a
distance value otherwise. To make use of the positioning difference, use
the special attribute &quot;@geodist&quot; in any of your filters or
sorting or grouping clauses.
</p>
<p>
And don&#8216;t forget - both the latitude and longitude you use in your <a
href="ClassMethods.html#M000054">search</a>, and the values in your
indexes, need to be stored as a float in radians, <em>not</em> degrees.
Keep in mind that if you do this conversion in SQL you will need to
explicitly declare a column type of :float.
</p>
<pre>
  define_index do
    has 'RADIANS(lat)', :as =&gt; :lat,  :type =&gt; :float
    # ...
  end
</pre>
<p>
Once you&#8216;ve got your results set, you can access the distances as
follows:
</p>
<pre>
  @results.each_with_geodist do |result, distance|
    # ...
  end
</pre>
<p>
The distance value is returned as a float, representing the distance in
metres.
</p>
<h2>Filtering by custom attributes</h2>
<p>
Do note that this applies only to sphinx 0.9.9
</p>
<p>
Should you find yourself in desperate need of a filter that involves
selecting either one of multiple conditions, one solution could be provided
by the :sphinx_select option within the <a
href="ClassMethods.html#M000054">search</a>. This handles which fields are
selected by sphinx from its store.
</p>
<p>
The default value is &quot;*&quot;, and you can add custom fields using
syntax similar to sql:
</p>
<pre>
  Flower.search &quot;foo&quot;,
    :sphinx_select =&gt; &quot;*, petals &lt; 1 or color = 2 as grass&quot;
</pre>
<p>
This will add the &#8216;grass&#8217; attribute, which will now be usable
in your filters.
</p>
<h2>Handling a Stale <a href="../Index.html">Index</a></h2>
<p>
Especially if you don&#8216;t use delta indexing, you risk having records
in the Sphinx index that are no longer in the database. By default, those
will simply come back as nils:
</p>
<pre>
  &gt;&gt; pat_user.delete
  &gt;&gt; User.search(&quot;pat&quot;)
  Sphinx Result: [1,2]
  =&gt; [nil, &lt;#User id: 2&gt;]
</pre>
<p>
(If you <a href="ClassMethods.html#M000054">search</a> across multiple
models, you&#8216;ll get ActiveRecord::RecordNotFound.)
</p>
<p>
You can simply Array#compact these results or handle the nils in some other
way, but Sphinx will still report two results, and the missing records may
upset your layout.
</p>
<p>
If you pass :retry_stale =&gt; true to a single-model <a
href="ClassMethods.html#M000054">search</a>, missing records will cause
Thinking Sphinx to retry the query but excluding those records. Since <a
href="ClassMethods.html#M000054">search</a> is paginated, the new <a
href="ClassMethods.html#M000054">search</a> could potentially include
missing records as well, so by default Thinking Sphinx will retry three
times. Pass :retry_stale =&gt; 5 to retry five times, and so on. If there
are still missing ids on the last retry, they are shown as nils.
</p>
        </div>
      </div>

      <div id="method-M000053" class="method-detail">
        <a name="M000053"></a>

        <div class="method-heading">
          <a href="ClassMethods.src/M000053.html" target="Code" class="method-signature"
            onclick="popupCode('ClassMethods.src/M000053.html');return false;">
          <span class="method-name">search_context</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000058" class="method-detail">
        <a name="M000058"></a>

        <div class="method-heading">
          <a href="ClassMethods.src/M000058.html" target="Code" class="method-signature"
            onclick="popupCode('ClassMethods.src/M000058.html');return false;">
          <span class="method-name">search_count</span><span class="method-args">(*args)</span>
          </a>
        </div>
      
        <div class="method-description">
        </div>
      </div>

      <div id="method-M000056" class="method-detail">
        <a name="M000056"></a>

        <div class="method-heading">
          <a href="ClassMethods.src/M000056.html" target="Code" class="method-signature"
            onclick="popupCode('ClassMethods.src/M000056.html');return false;">
          <span class="method-name">search_for_id</span><span class="method-args">(id, index, options = {})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Checks if a document with the given id exists within a specific index.
Expected parameters:
</p>
<ul>
<li>ID of the document

</li>
<li><a href="../Index.html">Index</a> to check within

</li>
<li>Options hash (defaults to {})

</li>
</ul>
<p>
Example:
</p>
<pre>
  ThinkingSphinx.search_for_id(10, &quot;user_core&quot;, :class =&gt; User)
</pre>
        </div>
      </div>

      <div id="method-M000055" class="method-detail">
        <a name="M000055"></a>

        <div class="method-heading">
          <a href="ClassMethods.src/M000055.html" target="Code" class="method-signature"
            onclick="popupCode('ClassMethods.src/M000055.html');return false;">
          <span class="method-name">search_for_ids</span><span class="method-args">(*args)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Searches for results that match the parameters provided. Will only return
the ids for the matching objects. See <a
href="ClassMethods.html#M000054">search</a> for syntax examples.
</p>
<p>
Note that this only searches the Sphinx index, with no <a
href="../ActiveRecord.html">ActiveRecord</a> queries. Thus, if your index
is not in sync with the database, this method may return ids that no longer
exist there.
</p>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>